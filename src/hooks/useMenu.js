import axios from 'axios'import {FileChunkSize, UploadAlreadyURL, UploadChunkURL, UploadMergeURL, UploadURL} from '@/utils/Constant'import {NProgress} from 'naive-ui'import {h, render} from 'vue'export const frameSelection = function(mainStore, message, uploadProgress){  let container = $('.n-scrollbar-container')    let mouseDown = false;    (function() {      let main = container      main[0].onmousedown = function() {        mouseDown = true        var selList = [];        var fileNodes = document.getElementsByClassName("item");        for (var i = 0; i < fileNodes.length; i++) {          if (fileNodes[i].className.indexOf("item") !== -1) {            fileNodes[i].className = "item";            selList.push(fileNodes[i]);          }        }        var isSelect = true;        var evt = window.event || arguments[0];        var startX = (evt.x || evt.clientX);        var startY = (evt.y || evt.clientY);        var selDiv = $('#selectDiv')[0];        selDiv.id = "selectDiv";        container.append(selDiv);        selDiv.style.left = startX + "px";        selDiv.style.top = startY + "px";        var _x = null;        var _y = null;        clearEventBubble(evt);        let startPoint = getRelativePositionInElement(evt.clientX, evt.clientY)        document.onmousemove = function() {          if (mouseDown) {            evt = window.event || arguments[0];            if (isSelect) {              if (selDiv.style.display === "none") {                selDiv.style.display = "";              }              _x = (evt.x || evt.clientX);              _y = (evt.y || evt.clientY);              let endPoint = getRelativePositionInElement(evt.clientX, evt.clientY)              selDiv.style.left = Math.min(startPoint.x, endPoint.x) + "px";              selDiv.style.top = Math.min(startPoint.y, endPoint.y) + "px";              selDiv.style.width = Math.abs(startPoint.x - endPoint.x) + "px";              selDiv.style.height = Math.abs(startPoint.y - endPoint.y) + "px";              scrollOnDrag(evt.clientX, evt.clientY)              // ---------------- 关键算法 ---------------------              let selDivRect = selDiv.getBoundingClientRect();              const left1 = selDivRect.left;              const right1 = selDivRect.left + selDivRect.width;              const top1 = selDivRect.top;              const bottom1 = selDivRect.top + selDivRect.height;              const width1 = selDivRect.width;              const height1 = selDivRect.height;              for (let i = 0; i < selList.length; i++) {                const itemRect = selList[i].getBoundingClientRect()                const left2 = itemRect.left;                const right2 = itemRect.left + itemRect.width;                const top2 = itemRect.top;                const bottom2 = itemRect.top + itemRect.height;                const width2 = itemRect.width;                const height2 = itemRect.height;                if (!(left2 > right1 || left1 > right2 || bottom1 < top2 || bottom2 < top1 || width1 <= 0 || width2 <= 0 || height1 <= 0 || height2 <= 0)) {                  if (selList[i].className.indexOf("seled") === -1) {                    selList[i].className = selList[i].className + " seled";                  }                } else {                  if (selList[i].className.indexOf("seled") !== -1) {                    selList[i].className = "item";                  }                }              }            }            clearEventBubble(evt);          }        }        document.onmouseup = function() {          mouseDown = false          isSelect = false;          if (selDiv) {            selDiv.style.display = 'none'            showSelDiv(selList);          }          selList = null, _x = null, _y = null, selDiv = null, startX = null, startY = null, evt = null;        }      }    })();    function clearEventBubble(evt) {      if (evt.stopPropagation)        evt.stopPropagation();      else        evt.cancelBubble = true;      if (evt.preventDefault)        evt.preventDefault();      else        evt.returnValue = false;    }    function showSelDiv(arr) {      mainStore.dragMoveList = []      mainStore.operationList = []      for (let i = 0; i < arr.length; i++) {        if (arr[i].className.indexOf("seled") !== -1) {          mainStore.dragMoveList.push($(arr[i]).find('input').val())          mainStore.operationList.push($(arr[i]).find('input').val())        }      }    }    function getRelativePositionInElement(clientX, clientY) {      const rect = container[0].getBoundingClientRect();      const {left, top} = rect;      const {scrollLeft, scrollTop, scrollWidth, scrollHeight} = container[0];      let x = clientX - left + scrollLeft;      let y = clientY - top + scrollTop;      if (x < 0) {        x = 0;      } else if (x > scrollWidth) {        x = scrollWidth;      }      if (y < 0) {        y = 0;      } else if (y > scrollHeight) {        y = scrollHeight;      }      return {x: Math.round(x), y: Math.round(y)};    }    function scrollOnDrag(mouseX, mouseY) {      const {x, y, width, height} = container[0].getBoundingClientRect();      let scrollX, scrollY;      if (mouseX < x) {        scrollX = mouseX - x;      } else if (mouseX > (x + width)) {        scrollX = mouseX - (x + width);      }      if (mouseY < y) {        scrollY = mouseY - y;      } else if (mouseY > (y + height)) {        scrollY = mouseY - (y + height);      }      if (scrollX || scrollY) {        container[0].scrollBy({          top: scrollY,          behavior: 'auto'        });      }    }  $('body')[0].addEventListener('dragover', function(ev) {    ev.preventDefault();  });  $('body')[0].addEventListener('drop', function(ev) {    ev.preventDefault();    for (let i = 0; i < ev.dataTransfer.items.length; i++) {      const item = ev.dataTransfer.items[i]      let entry = item.webkitGetAsEntry()      if (entry === null){        return      }      uploadProgress.value = true      if (item.kind === "file" && entry.isFile) {        let file = item.getAsFile()        let filename;        try {          filename = file.fullPath.split('/').slice(1).join('/')        } catch (e) {          filename = file.name        }        if (file.size > FileChunkSize) {          bigFile(file, mainStore, message, filename)        } else {          upload_file(file, mainStore, message, filename)        }      } else if (item.kind === "file" && entry.isDirectory) {        scan_file(entry)      }    }  });  function scan_file(item) {    let dirReader = item.createReader()    dirReader.readEntries(entries => {      for (let i = 0; i < entries.length; i++) {        if (entries[i].isFile) {          let filename;          try {            filename = entries[i].fullPath.split('/').slice(1).join('/')          } catch (e) {            filename = entries[i].name          }          entries[i].file(file => {            if (file.size > FileChunkSize) {              bigFile(file, mainStore, message, filename)            } else {              upload_file(file, mainStore, message, filename)            }          })        } else if (entries[i].isDirectory) {          scan_file(entries[i])        }      }    })  }}let instance = axios.create();instance.defaults.headers['Content-Type'] = 'multipart/form-data';instance.defaults.transformRequest = (data, headers) => {  const contentType = headers['Content-Type'];  if (contentType === "application/x-www-form-urlencoded") return Qs.stringify(data);  return data;};instance.interceptors.response.use(response => {  return response.data;});export async function bigFile(file, mainStore, message, filename) {  filename = filename.replace("[", "")  filename = filename.replace("]", "")  let md;  let filetype = setFileType(file)  const changeBuffer = file => {    return new Promise(resolve => {      let fileReader = new FileReader();      fileReader.readAsArrayBuffer(file);      fileReader.onload = ev => {        let buffer = ev.target.result,          spark = new SparkMD5.ArrayBuffer(),          HASH,          suffix;        spark.append(buffer);        HASH = spark.end();        let fileArray = new Int8Array(fileReader.result)        let fileHead = fileArray.subarray(0, 10)        let fileFoot = fileArray.subarray(fileArray.length - 11, fileArray.length - 1)        let value = `${fileHead.join('')}${fileFoot.join('')}${file.size}`        md = hex_md5(value)        suffix = /\.([a-zA-Z0-9]+)$/.exec(file.name)[1];        resolve({          buffer,          HASH,          suffix,          filename: `${HASH}.${suffix}`        });      };    });  };  // 获取文件的HASH  let already = [],    data = null,    {      HASH,      suffix    } = await changeBuffer(file);  // 获取已经上传的切片信息  try {    data = await instance.get(UploadAlreadyURL, {      params: {        HASH,        filename: filename,        parentId: mainStore.file_id,        fileHash: md      },      headers: {        'Authorization': localStorage.getItem('token')      }    }).finally(() => {      mainStore.init()    });    if (+data.code === 0) {      already = data.fileList;    } else if (+data.code === 2) {      return    } else {      message.error(data.msg)      return    }  } catch (err) {  }  // 实现文件切片处理 「固定数量 & 固定大小」  let max = 1024 * 100,    count = Math.ceil(file.size / max),    index = 0,    chunks = [];  if (count > 100) {    max = file.size / 100;    count = 100;  }  while (index < count) {    chunks.push({      file: file.slice(index * max, (index + 1) * max),      filename: `${HASH}_${index + 1}.${suffix}`    });    index++;  }  // 上传成功的处理  index = 0;  let filesize = file.size;  if (filesize > 1024 * 1024) {    filesize = (filesize / 1024 / 1024).toFixed(2) + ' MB'  } else {    filesize = (filesize / 1024).toFixed(2) + ' KB'  }  let progress = createProgress(file, filesize)  const complete = async () => {    // 管控进度条    index++;    $(progress.el).find('.n-progress-graph-line-fill').css('maxWidth', (index / count).toFixed(2) * 100 + '%')    $(progress.el).find('.n-progress-graph-line-indicator').text((index / count).toFixed(2) * 100 + '%')    // 当所有切片都上传成功，我们合并切片    if (index < count) return;    $(progress.el).find('.n-progress-graph-line-fill').css('maxWidth', '100%')    $(progress.el).find('.n-progress-graph-line-indicator').text('100%')    try {      axios.get(UploadMergeURL + '?HASH=' + HASH + '&count=' + count + '&parentId=' + mainStore.file_id + '&filename=' + filename + '&fileHash=' + md + '&filetype=' + filetype, {headers: {'Authorization': localStorage.getItem('token')}}).then((data) => {        if (data.data.code === 0 || data.data.code === 2) {          message.success(data.data.msg)        } else {          message.error(data.data.msg)        }      }).finally(() => {        mainStore.init()      });    } catch (err) {    }  };  // 把每一个切片都上传到服务器上  chunks.forEach(chunk => {    // 已经上传的无需在上传    if (already.length > 0 && already.includes(chunk.filename)) {      complete();      return;    }    let fm = new FormData;    fm.append(chunk.filename, chunk.file);    instance.post(UploadChunkURL, fm, {headers: {'Content-Type': 'multipart/form-data', 'Authorization': localStorage.getItem('token')}}).then(data => {      if (+data.code === 0) {        complete();        return;      }      return Promise.reject(data.codeText);    }).catch(() => {    });  });}function setFileType(file){  let filetype = 0  if (file.type === 'image/png' || file.type === 'image/gif' || file.type === 'image/jpeg') {    filetype = 2  } else if (file.type === 'video/mp4' || file.type === 'video/x-matroska' || file.type === 'video/avi') {    filetype = 3  } else if (file.type === 'application/pdf') {    filetype = 4  }  return filetype}export async function upload_file(file, mainStore, message, filename){  filename = filename.replace("[", "")  filename = filename.replace("]", "")  let fileReader = new FileReader();  let filetype = setFileType(file)  fileReader.readAsArrayBuffer(file);  let md;  fileReader.onload = ev => {    let fileArray = new Int8Array(fileReader.result)    let fileHead = fileArray.subarray(0, 10)    let fileFoot = fileArray.subarray(fileArray.length - 11, fileArray.length - 1)    let value = `${fileHead.join('')}${fileFoot.join('')}${file.size}`    md = hex_md5(value)    axios.get(UploadAlreadyURL + "?filename=" + filename + '&fileHash=' + md + '&parentId=' + mainStore.file_id, {headers: {'Authorization': localStorage.getItem('token')}}).then((data) => {      if (data.data.code === 0) {        const param = new FormData();        param.append("file", file)        let filesize = file.size;        if (filesize > 1024 * 1024) {          filesize = (filesize / 1024 / 1024).toFixed(2) + ' MB'        } else {          filesize = (filesize / 1024).toFixed(2) + ' KB'        }        let file_axios = axios.create();        let fileReader = new FileReader();        fileReader.readAsArrayBuffer(file);        fileReader.onload = ev => {          let buffer = ev.target.result,            spark = new SparkMD5.ArrayBuffer(),            HASH;          spark.append(buffer);          HASH = spark.end();          let progress = createProgress(file, filesize)          file_axios({            url: UploadURL + "?parentId=" + mainStore.file_id + '&filename=' + filename + '&HASH=' + HASH + '&fileHash=' + md + '&filetype=' + filetype,            method: 'post',            headers: {"Content-Type": "multipart/form-data", 'Authorization': localStorage.getItem('token')},            data: param,            onUploadProgress: function(progressEvent) {              if (progressEvent.loaded !== progressEvent.total) {                $(progress.el).find('.n-progress-graph-line-fill').css('maxWidth', (progressEvent.loaded / progressEvent.total).toFixed(2) * 100 + '%')                $(progress.el).find('.n-progress-graph-line-indicator').text((progressEvent.loaded / progressEvent.total).toFixed(2) + '%')              } else {                $(progress.el).find('.n-progress-graph-line-fill').css('maxWidth', '100%')                $(progress.el).find('.n-progress-graph-line-indicator').text('100%')              }            }          }).then((res) => {            if (res.data.code === 0) {            } else {              message.error(res.data.msg)            }          }).finally(() => {            mainStore.init()          })        }      } else if (data.data.code === 2) {        let filesize = file.size;        if (filesize > 1024 * 1024) {          filesize = (filesize / 1024 / 1024).toFixed(2) + ' MB'        } else {          filesize = (filesize / 1024).toFixed(2) + ' KB'        }      } else {        message.error(data.data.msg)      }    }).finally(() => {      mainStore.init()    })  };}function createProgress(file, filesize){  let div = document.createElement('div')  div.className = 'detail'  let filename = file.name  if (filename.length > 18){    filename = filename.substring(0, 18)  }  div.innerHTML = `<div class="fileDetail"><span>${filename}</span><span>${filesize}</span></div><div class="nprogress"></div>`  let progress = h(NProgress, {type: 'line', percentage: 0, indicatorPlacement: 'inside'})  render(progress, $(div).find('.nprogress')[0], undefined)  $('#upload_progress').find('.progress').append(div)  return progress}